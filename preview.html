<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS 2 Educational Module - Preview</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1, h2, h3 {
            color: #2e8555;
        }
        .chapter {
            margin-bottom: 40px;
            padding: 20px;
            border-left: 4px solid #2e8555;
            background-color: #f8f9fa;
        }
        .code-block {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: monospace;
        }
        .nav {
            text-align: center;
            margin-bottom: 30px;
        }
        .nav a {
            display: inline-block;
            padding: 10px 20px;
            margin: 0 10px;
            background-color: #2e8555;
            color: white;
            text-decoration: none;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Robotics Education Platform</h1>
    <p>This is a preview of the "Robotic Nervous System (ROS 2)" educational module.</p>
    
    <div class="nav">
        <a href="#chapter1">Chapter 1</a>
        <a href="#chapter2">Chapter 2</a>
        <a href="#chapter3">Chapter 3</a>
    </div>

    <div class="chapter" id="chapter1">
        <h2>Chapter 1: ROS 2 Basics</h2>
        <h3>Introduction to ROS 2</h3>
        <p>ROS 2 (Robot Operating System 2) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms.</p>
        
        <h3>Key Concepts in ROS 2</h3>
        <h4>Nodes</h4>
        <p>A node is a process that performs computation. ROS 2 is designed to be modular at the level of a node — a robot control system usually consists of many nodes. For example, one node controls a laser range finder, one node controls the wheels, and one node might listen to the laser data and compute safe velocities to send to the wheel controller.</p>
        
        <h4>Topics</h4>
        <p>Topics are named buses over which nodes exchange messages. Each topic has a type associated with it. The type defines the structure of the data that will be passed over that bus. Multiple nodes can subscribe to a topic, and multiple nodes can publish to a topic.</p>
        
        <h4>Services</h4>
        <p>Services provide a request/response mechanism for communication between nodes. A service has a name, and a definition that specifies the structure of the request and response. When a node wants to use a service, it sends a request to that service and waits for a response.</p>
        
        <h4>Messages</h4>
        <p>Messages are the data structures that are passed between nodes. Every message has a type that defines its fields. ROS 2 comes with many predefined message types, and you can define your own message types as well.</p>
        
        <h3>Simple rclpy Example</h3>
        <div class="code-block">
import rclpy<br>
from rclpy.node import Node<br>
from std_msgs.msg import String<br>
<br>
class MinimalPublisher(Node):<br>
&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super().__init__('minimal_publisher')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.publisher_ = self.create_publisher(String, 'topic', 10)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timer_period = 0.5&nbsp;&nbsp;# seconds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.timer = self.create_timer(timer_period, self.timer_callback)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.i = 0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def timer_callback(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg = String()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg.data = f'Hello World: {self.i}'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.publisher_.publish(msg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.get_logger().info(f'Publishing: "{msg.data}"')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.i += 1<br>
<br>
def main(args=None):<br>
&nbsp;&nbsp;&nbsp;&nbsp;rclpy.init(args=args)<br>
&nbsp;&nbsp;&nbsp;&nbsp;minimal_publisher = MinimalPublisher()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;try:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rclpy.spin(minimal_publisher)<br>
&nbsp;&nbsp;&nbsp;&nbsp;except KeyboardInterrupt:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass<br>
&nbsp;&nbsp;&nbsp;&nbsp;finally:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minimal_publisher.destroy_node()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rclpy.shutdown()<br>
<br>
if __name__ == '__main__':<br>
&nbsp;&nbsp;&nbsp;&nbsp;main()
        </div>
    </div>

    <div class="chapter" id="chapter2">
        <h2>Chapter 2: AI Agents → Robot Control</h2>
        <h3>Connecting AI Agents to ROS Controllers</h3>
        <p>In this chapter, we'll explore how to bridge Python-based AI agents with ROS 2 controllers to enable intelligent robot behavior. This connection forms the "brain" of our robotic system, allowing AI algorithms to control physical or simulated robots.</p>
        
        <h3>Using rclpy to Publish and Subscribe</h3>
        <p>Here's an example of how an AI agent can publish movement commands to a robot:</p>
        
        <div class="code-block">
import rclpy<br>
from rclpy.node import Node<br>
from geometry_msgs.msg import Twist<br>
from sensor_msgs.msg import LaserScan<br>
import numpy as np<br>
<br>
class AINavigationAgent(Node):<br>
&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super().__init__('ai_navigation_agent')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Publisher for robot velocity commands<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Subscriber for laser scan data (sensor input)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.scan_subscriber = self.create_subscription(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LaserScan,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'/scan',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.scan_callback,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Timer for AI decision-making loop<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.timer = self.create_timer(0.1, self.ai_decision_loop)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Internal state<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.laser_data = None<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.linear_velocity = 0.0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.angular_velocity = 0.0<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;def scan_callback(self, msg):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Process incoming laser scan data"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.laser_data = msg.ranges<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;def ai_decision_loop(self):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Main AI decision-making function"""<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.laser_data is None:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Simple obstacle avoidance algorithm<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd_vel = self.simple_avoidance_algorithm()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Publish the command<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.cmd_vel_publisher.publish(cmd_vel)<br>
        </div>
    </div>

    <div class="chapter" id="chapter3">
        <h2>Chapter 3: Humanoid Structure with URDF</h2>
        <h3>Introduction to URDF</h3>
        <p>URDF (Unified Robot Description Format) is an XML format used in ROS to describe robot models. It defines the physical and visual properties of a robot, including its links, joints, inertial properties, and sensors. URDF is essential for simulating robots in environments like Gazebo and for visualizing them in RViz.</p>
        
        <h3>Basic URDF Concepts</h3>
        <h4>Links</h4>
        <p>Links represent rigid bodies in a robot. Each link has:
        <ul>
            <li>Visual properties (shape, color, mesh)</li>
            <li>Collision properties (collision geometry)</li>
            <li>Inertial properties (mass, center of mass, inertia tensor)</li>
        </ul></p>
        
        <h4>Joints</h4>
        <p>Joints connect links and define how they can move relative to each other. Common joint types include:
        <ul>
            <li><strong>Fixed</strong>: No movement between links</li>
            <li><strong>Revolute</strong>: Rotational movement around an axis</li>
            <li><strong>Continuous</strong>: Unlimited rotational movement</li>
            <li><strong>Prismatic</strong>: Linear sliding movement</li>
            <li><strong>Floating</strong>: 6 degrees of freedom</li>
            <li><strong>Planar</strong>: Movement in a plane</li>
        </ul></p>
        
        <h3>Simple Humanoid URDF Example</h3>
        <div class="code-block">
&lt;?xml version="1.0"?&gt;<br>
&lt;robot name="simple_humanoid"&gt;<br>
&nbsp;&nbsp;&lt;!-- Base Link --&gt;<br>
&nbsp;&nbsp;&lt;link name="base_link"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;visual&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box size="0.3 0.3 0.3"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;material name="blue"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;color rgba="0 0 1 1"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/material&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/visual&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;collision&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box size="0.3 0.3 0.3"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/collision&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;inertial&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mass value="1.0"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/inertial&gt;<br>
&nbsp;&nbsp;&lt;/link&gt;<br>
<br>
&nbsp;&nbsp;&lt;!-- Torso --&gt;<br>
&nbsp;&nbsp;&lt;link name="torso"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;visual&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box size="0.2 0.1 0.4"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;material name="red"&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;color rgba="1 0 0 1"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/material&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/visual&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;collision&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box size="0.2 0.1 0.4"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/geometry&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/collision&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;inertial&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;mass value="0.8"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/inertial&gt;<br>
&nbsp;&nbsp;&lt;/link&gt;<br>
&lt;/robot&gt;
        </div>
    </div>

    <footer>
        <p>This preview shows the educational content created for the ROS 2 module. To run the full Docusaurus site, restore network connectivity and run:</p>
        <div class="code-block">
npm install<br>
npm start
        </div>
        <p>See the README.md file for complete instructions.</p>
    </footer>
</body>
</html>